import{_ as i,c as e,b as t,o as a}from"./app-DVHp4VmC.js";const n="/HaiTang-Lab/assets/img-L1AFrrvc.png",l="/HaiTang-Lab/assets/img_1-CfoxfMxS.png",h={};function p(r,s){return a(),e("div",null,s[0]||(s[0]=[t('<div class="hint-container tip"><p class="hint-container-title">提示</p><p>在校招和初级岗位的面试中使用该案例会很有效果，但是整体来说它是一个简单的案例，所以面一些比较高端的岗位的时候，它并不能为你赢得竞争优势。</p><p>这个案例可以作为你排查数据库性能问题的案例，也可以作为性能优化的案例。</p></div><p><strong>内容</strong> <br> 索引失效有很多种可能，你可以从这个问题里面<a href="https://github.com/hhhbx/HaiTang-Lab/blob/main/docs/notes/theme/interview/x-interview4.md" target="_blank" rel="noopener noreferrer">为什么定义了索引，但是最终数据库却没有用上？</a>找到详细的描述，这个案例描述的是在一些特定的场景下，MySQL 会放弃使用索引，选择使用全表扫描。 就弃用索引选择全表扫描而言，MySQL 本身自认为是做了一个合理的决策，但是实际中可能 MySQL 的这个决策可能效果并不是很好。在这个案例里面我们通过构造 WHERE 查询，导致 MySQL 判定候选的数据非常多，从而放弃使用索引，转而使用全表扫描。</p><p>其实整个案例非常简单。如果你执行这个 SQL：</p><div class="language-sql" data-ext="sql" data-title="sql"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">select</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> *</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> from</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> `</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">orders</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">`</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> where</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> uid</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> =</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 123</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> and</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> create_time </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">2024-10-25 18:47:59</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">;</span></span></code></pre></div><p>执行 EXPLAIN 命令，你会发现它会使用索引： <img src="'+n+'" alt="img.png"> 而后如果你执行这个 SQL：</p><div class="language-sql" data-ext="sql" data-title="sql"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">  select</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> *</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> from</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> `</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">orders</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">`</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> where</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> uid</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> =</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 123</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> and</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> create_time </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">2024-09-13 18:47:59</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">;</span></span></code></pre></div><p>执行 EXPLAIN 命令，你会发现它不会使用索引： <img src="'+l+'" alt="img_1.png"> 而这两个查询唯一不同的就是查询条件。第一个 SQL 命中少量的数据，而第二个 SQL 会命中大量的 SQL，这导致 MySQL 认为执行全表扫描性能会更好。</p><p><strong>适用场景和话术</strong><br> 在讨论到性能优化和 MySQL 的时候，你都可以考虑使用这个案例，例如这些问题：</p><p>你做过什么性能优化？</p><ul><li>你有没有遇到过全表扫描的问题？怎么解决的？</li><li>定义了索引以后，MySQL 查询一定会用索引吗？</li><li>为什么明明有索引，但是 MySQL 还是使用了全表扫描？<br><br></li></ul><p>在面试中使用这个案例的时候，可以参考这个话术来，要点是在于指出引起这个全表扫描的原因和对应的解决方案：</p><p>我之前就遇到过一个全表扫描的问题。<br> 简单来说，我们有一个范围查询，偶尔会非常慢。后来我通过日志发现，当查询条件比较宽泛的时候，就会出现查询非常慢的情况。<br> 这时候我就怀疑可能是因为查询条件没什么过滤的效果，导致 MySQL 认为使用全表查询会更好。<br> 因此我拿到这个查询，并且用同样的条件，用 EXPLAIN 看了一下，果然这个时候就发现这个查询是真的没有用索引。<br> 那么解决思路也很简单，就是可以通过 FOR INDEX 来确保查询一定会使用索引。<br> 你要额外小心一点，面试官可能会问你 EXPLAIN 命令的细节，你最好就是自己实际中真的使用一下 EXPALIN。<br><br></p><p>注意：这个案例并不稳定，也就是有时候你可能看到它确实用了索引，有时候它又没有使用索引，这主要是因为 MySQL 判定机制就是一个综合的复杂的机制，所以可能会出现这种问题。但是经过我们的测试，大多数时候你都能看到它使用全表扫描。</p><ul><li>引导点： EXPLAIN命令；</li><li>速记点： 范围查询过滤差，全表查询难避免；</li><li>亮 点： 优化全表扫描</li></ul><p><strong>好的，我们来详细讲解一下 <code>EXPLAIN</code> 命令的细节，以及如何利用它来分析和优化 SQL 查询。</strong><strong>什么是 EXPLAIN 命令？</strong><code>EXPLAIN</code> 命令是 MySQL 提供的一个非常有用的工具，它可以让你了解 MySQL 如何执行 SQL 查询。通过 <code>EXPLAIN</code> 命令，你可以看到查询的执行计划，包括是否使用了索引、使用了哪种类型的索引、扫描了多少行数据等等。这些信息对于分析查询性能瓶颈、优化 SQL 查询非常有帮助。</p><h2 id="如何使用-explain-命令" tabindex="-1"><a class="header-anchor" href="#如何使用-explain-命令"><span>如何使用 EXPLAIN 命令？</span></a></h2><p>使用 <code>EXPLAIN</code> 命令非常简单，只需要在 SQL 查询语句前面加上 <code>EXPLAIN</code> 关键字即可。例如：</p><div class="language-sql" data-ext="sql" data-title="sql"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">EXPLAIN </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">SELECT</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> *</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> FROM</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> users </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">WHERE</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> id </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 10</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">;</span></span></code></pre></div><p>执行以上命令后，MySQL 会返回一个结果集，包含查询的执行计划。</p><p><strong>EXPLAIN 命令返回的列</strong></p><p><code>EXPLAIN</code> 命令返回的结果集包含多列，每一列都代表了查询执行计划的不同方面。下面是 <code>EXPLAIN</code> 命令返回的常用列：</p><ul><li><strong>id：</strong> 查询的标识符。如果查询包含子查询，则每个子查询都会有一个单独的 id。</li><li><strong>select_type：</strong> 查询的类型。常见的类型包括 SIMPLE（简单查询）、PRIMARY（主查询）、SUBQUERY（子查询）、DERIVED（派生表）等。</li><li><strong>table：</strong> 查询访问的表。</li><li><strong>partitions：</strong> 查询访问的分区。</li><li><strong>type：</strong> 连接类型。表示 MySQL 如何查找表中的行。常见的类型包括： <ul><li><strong>SYSTEM：</strong> 表中只有一行数据，通常用于系统表。</li><li><strong>CONST：</strong> MySQL 可以通过常数来优化查询，例如查询主键或唯一索引。</li><li><strong>EQ_REF：</strong> 使用唯一索引或主键索引进行查找。</li><li><strong>REF：</strong> 使用非唯一索引进行查找。</li><li><strong>FULLTEXT：</strong> 使用全文索引进行查找。</li><li><strong>RANGE：</strong> 使用索引进行范围查找。</li><li><strong>INDEX：</strong> 全索引扫描。</li><li><strong>ALL：</strong> 全表扫描。</li></ul></li><li><strong>possible_keys：</strong> 可能用于查询的索引。</li><li><strong>key：</strong> 实际使用的索引。</li><li><strong>key_len：</strong> 使用的索引长度。</li><li><strong>ref：</strong> 与索引列进行比较的常量或列。</li><li><strong>rows：</strong> 估计需要扫描的行数。</li><li><strong>filtered：</strong> 过滤的行数百分比。</li><li><strong>Extra：</strong> 包含不适合在其他列中显示的额外信息。</li></ul><p><strong>如何分析 EXPLAIN 命令的结果？</strong></p><p>通过分析 <code>EXPLAIN</code> 命令返回的结果，你可以了解查询的执行计划，从而找到查询性能瓶颈。以下是一些常见的分析技巧：</p><ul><li><strong>关注 type 列：</strong> <code>type</code> 列表示连接类型，它的值越好，查询性能就越高。一般来说，<code>type</code> 列的值应该在 <code>EQ_REF</code>、<code>REF</code>、<code>RANGE</code> 之间。如果 <code>type</code> 列的值是 <code>INDEX</code> 或 <code>ALL</code>，则表示查询使用了全索引扫描或全表扫描，这通常是查询性能瓶颈。</li><li><strong>关注 key 列：</strong> <code>key</code> 列表示实际使用的索引。如果 <code>key</code> 列的值为空，则表示查询没有使用索引，这通常是查询性能瓶颈。</li><li><strong>关注 rows 列：</strong> <code>rows</code> 列表示估计需要扫描的行数。<code>rows</code> 列的值越小，查询性能就越高。</li><li><strong>关注 Extra 列：</strong> <code>Extra</code> 列包含一些额外的信息，例如是否使用了临时表、是否使用了文件排序等。这些信息可以帮助你更深入地了解查询的执行计划。</li></ul><h2 id="如何优化-sql-查询" tabindex="-1"><a class="header-anchor" href="#如何优化-sql-查询"><span>如何优化 SQL 查询？</span></a></h2><p>通过 <code>EXPLAIN</code> 命令分析查询执行计划后，你可以根据分析结果来优化 SQL 查询。以下是一些常见的优化技巧：</p><ul><li><strong>添加索引：</strong> 如果查询没有使用索引，或者使用了全索引扫描或全表扫描，则可以考虑添加索引来提高查询性能。</li><li><strong>优化索引：</strong> 如果查询使用了索引，但是索引效率不高，则可以考虑优化索引，例如调整索引列的顺序、添加覆盖索引等。</li><li><strong>重写 SQL 查询：</strong> 有时候，SQL 查询的写法不够优化，可以尝试重写 SQL 查询来提高查询性能。</li></ul><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p><code>EXPLAIN</code> 命令是 MySQL 提供的一个非常有用的工具，它可以让你了解 MySQL 如何执行 SQL 查询。通过 <code>EXPLAIN</code> 命令，你可以分析查询性能瓶颈，并根据分析结果来优化 SQL 查询。掌握 <code>EXPLAIN</code> 命令的使用，对于提高 SQL 查询性能非常有帮助。</p><p>希望以上信息对您有所帮助！如果您有任何问题，欢迎随时提出。</p><p><strong>好的，我们来详细讲解一下如何通过 <code>FOR INDEX</code> 来确保查询一定会使用索引。</strong></p><p><strong>为什么需要强制使用索引？</strong></p><p>MySQL 查询优化器会根据查询条件、数据量等因素，自动选择合适的索引来执行查询。但是，在某些情况下，优化器可能会选择不使用索引，或者选择了效率较低的索引，导致查询性能下降。这时，我们可以通过 <code>FOR INDEX</code> 来强制 MySQL 使用指定的索引，以提高查询性能。</p><h2 id="如何使用-for-index" tabindex="-1"><a class="header-anchor" href="#如何使用-for-index"><span>如何使用 FOR INDEX？</span></a></h2><p><code>FOR INDEX</code> 语法非常简单，只需要在 SQL 查询语句中的 <code>FROM</code> 子句后面加上 <code>FOR INDEX (index_name)</code> 即可。其中，<code>index_name</code> 是你要强制使用的索引名称。例如：</p><div class="language-sql" data-ext="sql" data-title="sql"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">SELECT</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> *</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> FROM</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> users </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">FOR</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> INDEX</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> (idx_name) </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">WHERE</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> id </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 10</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">;</span></span></code></pre></div><p>以上 SQL 查询语句会强制 MySQL 使用名为 <code>idx_name</code> 的索引来查询 <code>users</code> 表中 <code>id</code> 大于 10 的数据。</p><h2 id="使用-for-index-的注意事项" tabindex="-1"><a class="header-anchor" href="#使用-for-index-的注意事项"><span>使用 FOR INDEX 的注意事项</span></a></h2><ul><li><strong>确保索引存在：</strong> 在使用 <code>FOR INDEX</code> 之前，必须确保指定的索引已经存在。</li><li><strong>选择合适的索引：</strong> 选择合适的索引对于提高查询性能非常重要。如果选择了不合适的索引，可能会导致查询性能更差。</li><li><strong>了解索引的局限性：</strong> 索引并不是万能的。在某些情况下，即使使用了索引，查询性能也可能无法达到预期。</li><li><strong>谨慎使用：</strong> 强制使用索引可能会导致查询性能下降，因此应该谨慎使用。只有在确定优化器选择的索引不合适时，才应该考虑使用 <code>FOR INDEX</code>。</li></ul><h2 id="示例" tabindex="-1"><a class="header-anchor" href="#示例"><span>示例</span></a></h2><p>假设我们有一个名为 <code>orders</code> 的表，其中包含 <code>order_id</code>、<code>user_id</code>、<code>order_date</code> 等字段。我们在 <code>user_id</code> 字段上创建了一个索引 <code>idx_user_id</code>。</p><p>现在，我们需要查询 <code>user_id</code> 为 123 的所有订单。我们可以使用以下 SQL 查询语句：</p><div class="language-sql" data-ext="sql" data-title="sql"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">SELECT</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> *</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> FROM</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> orders </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">WHERE</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> user_id </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 123</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">;</span></span></code></pre></div><p>如果 MySQL 查询优化器没有选择使用 <code>idx_user_id</code> 索引，我们可以使用 <code>FOR INDEX</code> 来强制 MySQL 使用该索引：</p><div class="language-sql" data-ext="sql" data-title="sql"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">SELECT</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> *</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> FROM</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> orders </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">FOR</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> INDEX</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> (idx_user_id) </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">WHERE</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> user_id </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 123</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">;</span></span></code></pre></div><h2 id="总结-1" tabindex="-1"><a class="header-anchor" href="#总结-1"><span>总结</span></a></h2><p><code>FOR INDEX</code> 是一种强制 MySQL 使用指定索引的方法。通过 <code>FOR INDEX</code>，我们可以控制 MySQL 的查询执行计划，从而提高查询性能。但是，在使用 <code>FOR INDEX</code> 时，我们需要注意一些事项，以避免出现意外的问题。</p><p>希望以上信息对您有所帮助！如果您有任何问题，欢迎随时提出。</p>',49)]))}const d=i(h,[["render",p],["__file","index.html.vue"]]),k=JSON.parse('{"path":"/interview/x-interview3/","title":"索引失效：使用全表扫描","lang":"zh-CN","frontmatter":{"title":"索引失效：使用全表扫描","createTime":"2025/02/08 18:32:03","permalink":"/interview/x-interview3/","description":"提示 在校招和初级岗位的面试中使用该案例会很有效果，但是整体来说它是一个简单的案例，所以面一些比较高端的岗位的时候，它并不能为你赢得竞争优势。 这个案例可以作为你排查数据库性能问题的案例，也可以作为性能优化的案例。 内容 索引失效有很多种可能，你可以从这个问题里面为什么定义了索引，但是最终数据库却没有用上？找到详细的描述，这个案例描述的是在一些特定的场...","head":[["meta",{"property":"og:url","content":"https://plume.pengzhanbo.cn/HaiTang-Lab/interview/x-interview3/"}],["meta",{"property":"og:site_name","content":"海棠实验室"}],["meta",{"property":"og:title","content":"索引失效：使用全表扫描"}],["meta",{"property":"og:description","content":"提示 在校招和初级岗位的面试中使用该案例会很有效果，但是整体来说它是一个简单的案例，所以面一些比较高端的岗位的时候，它并不能为你赢得竞争优势。 这个案例可以作为你排查数据库性能问题的案例，也可以作为性能优化的案例。 内容 索引失效有很多种可能，你可以从这个问题里面为什么定义了索引，但是最终数据库却没有用上？找到详细的描述，这个案例描述的是在一些特定的场..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-08T14:30:29.000Z"}],["meta",{"property":"article:modified_time","content":"2025-02-08T14:30:29.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"索引失效：使用全表扫描\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-02-08T14:30:29.000Z\\",\\"author\\":[]}"]]},"headers":[],"readingTime":{"minutes":8.95,"words":2685},"git":{"updatedTime":1739025029000,"contributors":[{"name":"hhhbx","username":"hhhbx","email":"972916730@qq.com","commits":2,"avatar":"https://avatars.githubusercontent.com/hhhbx?v=4","url":"https://github.com/hhhbx"}],"changelog":[{"hash":"bf6c2716afeafb2e292b78a0f798923cfa01a128","date":1739025029000,"email":"972916730@qq.com","author":"hhhbx","message":"feat(docs): 更新面试题","commitUrl":"https://github.com/pengzhanbo/vuepress-theme-plume/commit/bf6c2716afeafb2e292b78a0f798923cfa01a128"},{"hash":"72a9b1b34230dc88b6452a20283e54fe824cc69b","date":1739024507000,"email":"972916730@qq.com","author":"hhhbx","message":"feat(docs): 更新面试题","commitUrl":"https://github.com/pengzhanbo/vuepress-theme-plume/commit/72a9b1b34230dc88b6452a20283e54fe824cc69b"}]},"autoDesc":true,"filePathRelative":"notes/theme/interview/x-interview3.md","bulletin":false}');export{d as comp,k as data};
