import{_ as i,c as a,b as t,o as e}from"./app-DVHp4VmC.js";const h={};function n(l,s){return e(),a("div",null,s[0]||(s[0]=[t('<div class="hint-container tip"><p class="hint-container-title">提示</p><p>如果你平时没有想过，那么面试官问出来就很容易卡住。实际上这个问题并不难，但是可能的情况比较多，因此你在回答的时候，不一定能够把面试官想要你回答的所有的点都回答出来。但是并不要紧，你只需要答出三五个点就差不多了，足以证明你对这个问题有比较深刻的理解。</p><p>而后在平时注意收集一些索引失效的案例就可以了，尽量在回答的时候用上，就非常完美。</p></div><h2 id="题目分析" tabindex="-1"><a class="header-anchor" href="#题目分析"><span>题目分析</span></a></h2><p>数据库不用索引的原因有很多：</p><ul><li>WHERE 条件没有命中索引：这也是最简单的理由。例如说你的索引创建在列（A，B，C）上，结果你的 WHERE 部分只有 D 这一个列；</li><li>WHERE 条件不符合最左匹配原则：例如说在索引（A，B，C）上，你的查询 WHERE 部分只使用了 B 这个列。那么数据库也不会使用索引；</li><li>NOT IN 等取反的查询：正常 IN 查询是可以使用索引的，但是 NOT IN 就相当于不用某几个数据，也就是要全表扫描了；</li><li>索引列上使用了运算：虽然 WHERE 里面使用了索引列，但是并不是直接使用索引列，而是执行了计算、调用了方法等，例如说 WHERE a = b + 1 这种；</li><li>数据库有更加适合的索引：例如说你有 index_a 和 index_b 两个索引，如果数据库认为使用 index_b 更加合适，那么就不会使用 index_a 了；</li><li>数据量太小，或者查询命中的数据占比太高：这种情况下，数据库经过评估之后认为使用索引不能带来更好的性能，反而全表扫描会带来更好的性能，那么数据库也不会使用索引；<br><br></li></ul><p>面试官也可能换一些问法，比如说：</p><ul><li>你定义了索引，数据库就一定会用吗？并不一定；</li><li>什么是索引失效？为什么索引会失效？ 另外有一些面试官喜欢直接列出表结构定义，然后写出查询，问你为什么这个查询会不会走索引，走哪个索引，你记得问一句数据量大小，因为这个也会对索引有影响。而后你记得补充，最终还是要以数据库 EXPLAIN 为准，你自己这种理论分析是不靠谱的。</li></ul><p>当然，要是面试官问到慢查询排查，又或者 SQL 查询优化的时候，你也可以用索引失效作为其中的一个点。</p><h2 id="_15k-回答" tabindex="-1"><a class="header-anchor" href="#_15k-回答"><span>15K 回答</span></a></h2><p>（基本原因）数据库不用索引的原因有很多：</p><ul><li>WHERE 条件没有命中索引：例如说 WHERE 条件里面完全没有任何的索引列；</li><li>WHERE 条件不符合最左匹配原则：例如说索引（A，B，C），但是 WHERE 里面只有列 B 的查询条件；</li><li>NOT IN 等取反的查询：正常 IN 查询是可以使用索引的，但是 NOT IN 就相当于不用某几个数据，也就是要全表扫描了；</li><li>索引列使用了运算：最常见的就是索引列参与了数学运算，或者作为函数的参数；</li><li>数据库有更加适合的索引：这种其实很常见，或者说有时候我们会预期数据库使用 index_a，但是数据库可能最终用的是 index_b；</li><li>数据量太小，或者查询命中的数据占比太高：这种情况下，数据库经过评估之后认为全表扫描性能更好，那么也不会使用索引； 在实践中，遇到慢查询，或者 SQL 优化的时候，首先要确定的就是数据库究竟有没有用索引，用的是哪个索引，是否符合我们的预期。</li></ul><div class="hint-container tip"><p class="hint-container-title">提示</p><p>这里你其实已经留下了一个引导点，也就是怎么看数据库究竟有没有使用索引，用的是哪个索引。即使用 EXPLAIN 命令，即便是 NoSQL，它们多半也会提供类似的工具，方便你查看查询的执行计划。</p></div><p>（补充案例）比如说早期我就遇到过一个索引失效的问题。当时我们有一个慢查询，是一个简单的范围查询。大部分时候这个查询都运作非常正常，但是在偶发情况下就会特别慢。后面我去排查的时候就发现，这个查询在某几个大客户使用的时候就会特别慢。后面我在线上数据库用大客户的查询条件 EXPLAIN 了一下这个查询，发现这个查询已经退化为了全表扫描。</p><p>后面我就改写了查询，改成了一个分批查询，避免了一次加载数据太多，引发的索引失效问题。</p><ul><li>关键字： WHERE 最左匹配原则 全表扫描</li><li>引导点： EXPLAIN；</li><li>亮 点： 全表扫描案例；</li></ul><h2 id="_25k-回答" tabindex="-1"><a class="header-anchor" href="#_25k-回答"><span>25K 回答</span></a></h2><p>（进一步引导）数据库查询不使用索引的问题不仅仅在于查询会很慢，还可能引发更加严重的问题，比如说表锁。正常在 MySQL 的 Innodb 引擎中，对数据加锁是借助索引来实现的。如果没有命中任何索引，那么 Innodb 引擎就会使用表锁。</p><div class="hint-container tip"><p class="hint-container-title">提示</p><p>这里你可以补充一个没有命中索引导致的表锁案例。</p></div><h2 id="由于未命中索引导致表锁的案例" tabindex="-1"><a class="header-anchor" href="#由于未命中索引导致表锁的案例"><span><strong>由于未命中索引导致表锁的案例</strong></span></a></h2><h2 id="案例一" tabindex="-1"><a class="header-anchor" href="#案例一"><span>案例一</span></a></h2><p>好的，以下是一个更完整的案例，其中包含了由于没有命中索引而导致的表锁案例，并提供了相应的解决方案。</p><h3 id="_1-案例背景" tabindex="-1"><a class="header-anchor" href="#_1-案例背景"><span><strong>1.案例背景</strong></span></a></h3><p>假设我们有一个名为 <code>products</code> 的表，其中包含以下字段：</p><ul><li><code>id</code> (INT, PRIMARY KEY)</li><li><code>name</code> (VARCHAR)</li><li><code>price</code> (DECIMAL)</li><li><code>category_id</code> (INT)</li><li><code>created_at</code> (TIMESTAMP)</li></ul><p>我们在 <code>category_id</code> 字段上创建了一个索引 <code>idx_category_id</code>。</p><p>现在，我们需要查询 <code>category_id</code> 为 1 的所有商品。我们可以使用以下 SQL 查询语句：</p><div class="language-sql" data-ext="sql" data-title="sql"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">SELECT</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> *</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> FROM</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> products </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">WHERE</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> category_id </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">;</span></span></code></pre></div><h3 id="_2-问题描述" tabindex="-1"><a class="header-anchor" href="#_2-问题描述"><span><strong>2.问题描述</strong></span></a></h3><p>在某些情况下，我们可能会发现这个查询执行非常缓慢。通过使用 <code>EXPLAIN</code> 命令分析查询执行计划，我们可能会发现 <code>type</code> 列的值为 <code>ALL</code>，表示查询使用了全表扫描。</p><h3 id="_3-原因分析" tabindex="-1"><a class="header-anchor" href="#_3-原因分析"><span><strong>3.原因分析</strong></span></a></h3><p><code>EXPLAIN</code> 命令的结果表明，MySQL 查询优化器没有选择使用 <code>idx_category_id</code> 索引，而是选择了全表扫描。这可能是因为以下原因：</p><ul><li><strong>索引失效：</strong> 索引 <code>idx_category_id</code> 可能由于某些原因失效，例如索引碎片过多、索引统计信息不准确等。</li><li><strong>查询条件过于宽泛：</strong> 查询条件 <code>category_id = 1</code> 可能匹配了大量的行，导致 MySQL 认为全表扫描比使用索引更快。</li><li><strong>其他原因：</strong> 可能存在其他原因导致 MySQL 没有选择使用索引，例如查询语句的写法、数据库配置等。</li></ul><h3 id="_4-表锁问题" tabindex="-1"><a class="header-anchor" href="#_4-表锁问题"><span><strong>4.表锁问题</strong></span></a></h3><p>由于查询使用了全表扫描，可能会导致表锁问题。当一个查询需要扫描整个表时，它可能会获取一个表级锁，阻止其他事务对该表进行修改操作，从而影响并发性能。</p><h3 id="_5-解决方案" tabindex="-1"><a class="header-anchor" href="#_5-解决方案"><span><strong>5.解决方案</strong></span></a></h3><p>针对以上问题，我们可以采取以下解决方案：</p><ol><li><strong>重建索引：</strong> 如果索引 <code>idx_category_id</code> 失效，可以尝试重建索引。</li><li><strong>优化查询条件：</strong> 如果查询条件过于宽泛，可以尝试缩小查询范围，例如添加其他过滤条件。</li><li><strong>强制使用索引：</strong> 可以使用 <code>FOR INDEX</code> 语法强制 MySQL 使用指定的索引。</li><li><strong>分析查询执行计划：</strong> 使用 <code>EXPLAIN</code> 命令分析查询执行计划，找出查询性能瓶颈。</li><li><strong>优化数据库配置：</strong> 检查数据库配置，例如 <code>innodb_buffer_pool_size</code> 等，确保数据库配置合理。</li></ol><h3 id="_6-案例示例" tabindex="-1"><a class="header-anchor" href="#_6-案例示例"><span><strong>6.案例示例</strong></span></a></h3><p>假设我们发现查询条件 <code>category_id = 1</code> 匹配了大量的行，导致 MySQL 选择了全表扫描。我们可以尝试添加其他过滤条件，例如：</p><div class="language-sql" data-ext="sql" data-title="sql"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">SELECT</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> *</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> FROM</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> products </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">WHERE</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> category_id </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> AND</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> price </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 100</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">;</span></span></code></pre></div><p>如果 MySQL 仍然没有选择使用索引，我们可以使用 <code>FOR INDEX</code> 语法强制 MySQL 使用 <code>idx_category_id</code> 索引：</p><div class="language-sql" data-ext="sql" data-title="sql"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">SELECT</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> *</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> FROM</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> products </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">FOR</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> INDEX</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> (idx_category_id) </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">WHERE</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> category_id </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> AND</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> price </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 100</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">;</span></span></code></pre></div><h3 id="_7-总结" tabindex="-1"><a class="header-anchor" href="#_7-总结"><span><strong>7.总结</strong></span></a></h3><p>通过以上案例，我们可以了解到由于没有命中索引而导致全表扫描和表锁的问题，并学习了如何通过重建索引、优化查询条件、强制使用索引等方法来解决这些问题。在实际开发中，我们需要根据具体情况选择合适的解决方案，以提高查询性能和并发性能。</p><h2 id="案例二" tabindex="-1"><a class="header-anchor" href="#案例二"><span>案例二</span></a></h2><p>在 MySQL 数据库中，如果查询没有命中索引，可能会导致 <strong>全表扫描</strong>，进而引发 <strong>表锁</strong>。以下是一个具体的案例，说明如何因为索引未命中导致表锁，并给出优化方案。</p><hr><h3 id="_1-场景描述" tabindex="-1"><a class="header-anchor" href="#_1-场景描述"><span><strong>1. 场景描述</strong></span></a></h3><p>公司 ERP 系统中有一张 <code>order</code> 订单表，该表结构如下：</p><div class="language-sql" data-ext="sql" data-title="sql"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">CREATE</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> TABLE</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> `</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">order</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">` (</span></span>\n<span class="line"><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">    `</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">id</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">`</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> BIGINT</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> PRIMARY KEY</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> AUTO_INCREMENT,</span></span>\n<span class="line"><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">    `</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">order_no</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">`</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> VARCHAR</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">50</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">) </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">NOT NULL</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">,</span></span>\n<span class="line"><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">    `</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">user_id</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">`</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> BIGINT</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> NOT NULL</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">,</span></span>\n<span class="line"><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">    `</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">status</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">`</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> TINYINT</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> NOT NULL</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> DEFAULT</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">,  </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">-- 订单状态（0:待支付, 1:已支付, 2:已取消）</span></span>\n<span class="line"><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">    `</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">created_at</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">`</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> DATETIME</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> NOT NULL</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> DEFAULT</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> CURRENT_TIMESTAMP,</span></span>\n<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    INDEX</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> idx_user_id (user_id)  </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">-- 仅对 user_id 建立索引</span></span>\n<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">) ENGINE</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">=</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">InnoDB </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">DEFAULT</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> CHARSET</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">=</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">utf8mb4;</span></span></code></pre></div><p>在并发环境下，某个业务逻辑会执行以下 <code>UPDATE</code> 语句，修改特定用户的订单状态：</p><div class="language-sql" data-ext="sql" data-title="sql"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">UPDATE</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> order </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">SET</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> status</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> =</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> WHERE</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> order_no </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">=</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">HT20240208001</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">;</span></span></code></pre></div><hr><h3 id="_2-问题分析" tabindex="-1"><a class="header-anchor" href="#_2-问题分析"><span><strong>2. 问题分析</strong></span></a></h3><p>执行 <code>EXPLAIN</code> 语句查看 SQL 语句的执行计划：</p><div class="language-sql" data-ext="sql" data-title="sql"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">EXPLAIN </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">UPDATE</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> order </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">SET</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> status</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> =</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> WHERE</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> order_no </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">=</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">HT20240208001</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">;</span></span></code></pre></div><p>查询结果如下：</p><table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>order</td><td>ALL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>100000</td><td>Using where</td></tr></tbody></table><h4 id="问题点" tabindex="-1"><a class="header-anchor" href="#问题点"><span><strong>问题点</strong></span></a></h4><ul><li><strong>索引未命中</strong>：表中 <strong><code>order_no</code> 没有索引</strong>，查询条件 <code>WHERE order_no = &#39;HT20240208001&#39;</code> 只能 <strong>全表扫描（ALL）</strong>。</li><li><strong>表锁风险</strong>： <ul><li>InnoDB 默认是 <strong>行锁（row-level lock）</strong>，但<strong>由于没有命中索引</strong>，会导致 <strong>表锁（table lock）</strong>，影响并发操作。</li><li>在高并发环境下，多个事务尝试修改不同 <code>order_no</code> 的数据，但由于表锁，<strong>所有事务被串行执行</strong>，导致性能急剧下降。</li></ul></li></ul><hr><h3 id="_3-复现问题" tabindex="-1"><a class="header-anchor" href="#_3-复现问题"><span><strong>3. 复现问题</strong></span></a></h3><h4 id="_1-事务a-修改订单状态" tabindex="-1"><a class="header-anchor" href="#_1-事务a-修改订单状态"><span><strong>（1）事务A：修改订单状态</strong></span></a></h4><div class="language-sql" data-ext="sql" data-title="sql"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">START TRANSACTION</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">;</span></span>\n<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">UPDATE</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> order </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">SET</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> status</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> =</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> WHERE</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> order_no </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">=</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">HT20240208001</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">;</span></span>\n<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">-- 事务A未提交，表被锁住</span></span></code></pre></div><h4 id="_2-事务b-修改另一条订单" tabindex="-1"><a class="header-anchor" href="#_2-事务b-修改另一条订单"><span><strong>（2）事务B：修改另一条订单</strong></span></a></h4><div class="language-sql" data-ext="sql" data-title="sql"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">START TRANSACTION</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">;</span></span>\n<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">UPDATE</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> order </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">SET</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> status</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> =</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> WHERE</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> order_no </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">=</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">HT20240208002</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">;</span></span>\n<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">-- 事务B等待事务A释放锁</span></span></code></pre></div><p>此时，<strong>事务 B 被阻塞</strong>，因为 <code>UPDATE</code> 语句由于全表扫描导致表锁，使所有对 <code>order</code> 表的修改都需要等待事务 A 提交。</p><hr><h3 id="_4-解决方案" tabindex="-1"><a class="header-anchor" href="#_4-解决方案"><span><strong>4. 解决方案</strong></span></a></h3><h4 id="方案-1-为-order-no-创建索引" tabindex="-1"><a class="header-anchor" href="#方案-1-为-order-no-创建索引"><span><strong>方案 1：为 <code>order_no</code> 创建索引</strong></span></a></h4><div class="language-sql" data-ext="sql" data-title="sql"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">ALTER</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> TABLE</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> order </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">ADD</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> INDEX</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> idx_order_no (order_no);</span></span></code></pre></div><p>再次执行 <code>EXPLAIN</code>，可以看到索引被正确使用：</p><div class="language-sql" data-ext="sql" data-title="sql"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">EXPLAIN </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">UPDATE</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> order </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">SET</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> status</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> =</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> WHERE</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> order_no </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">=</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">HT20240208001</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">;</span></span></code></pre></div><table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>order</td><td>ref</td><td>idx_order_no</td><td>idx_order_no</td><td>50</td><td>const</td><td>1</td><td>Using index</td></tr></tbody></table><ul><li><strong>查询性能提升</strong>：<code>type</code> 由 <code>ALL</code>（全表扫描）变为 <code>ref</code>（使用索引）。</li><li><strong>避免表锁</strong>：仅锁住 <code>order_no = &#39;HT20240208001&#39;</code> 的行，事务 B 也可以更新其他 <code>order_no</code>，不再阻塞。</li></ul><hr><h4 id="方案-2-使用-order-by-limit-1-适用于行锁问题" tabindex="-1"><a class="header-anchor" href="#方案-2-使用-order-by-limit-1-适用于行锁问题"><span><strong>方案 2：使用 <code>ORDER BY</code> + <code>LIMIT 1</code>（适用于行锁问题）</strong></span></a></h4><p>如果 <code>order_no</code> 不是唯一键，可能会影响锁粒度，可以加 <code>LIMIT 1</code> 限制影响行数：</p><div class="language-sql" data-ext="sql" data-title="sql"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">UPDATE</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> order </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">SET</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> status</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> =</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> WHERE</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> order_no </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">=</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">HT20240208001</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> LIMIT</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">;</span></span></code></pre></div><p><strong>作用：</strong></p><ul><li>MySQL 会尽量锁定少量数据，避免锁住不必要的行。</li></ul><hr><h3 id="_5-总结" tabindex="-1"><a class="header-anchor" href="#_5-总结"><span><strong>5. 总结</strong></span></a></h3><table><thead><tr><th>问题</th><th>影响</th><th>解决方案</th></tr></thead><tbody><tr><td>未命中索引导致全表扫描</td><td>事务执行慢，锁表影响并发</td><td><strong>创建索引</strong>（<code>ALTER TABLE order ADD INDEX idx_order_no (order_no)</code>）</td></tr><tr><td>InnoDB 可能锁住过多行</td><td>事务阻塞，导致并发降低</td><td><strong><code>LIMIT 1</code> 限制锁行数</strong></td></tr></tbody></table><p>这个案例展示了：</p><ol><li><strong>索引缺失导致全表扫描，进而引发表锁</strong>。</li><li><strong>索引优化如何显著提高 MySQL 查询性能，避免锁冲突</strong>。</li></ol><p>如果你在项目中遇到类似问题，可以尝试 <code>EXPLAIN</code> 检查索引命中情况，并优化索引来提升性能 🚀。</p><ul><li>关键字： 表锁</li><li>引导点： 表锁；锁机制；</li></ul>',87)]))}const d=i(h,[["render",n],["__file","index.html.vue"]]),k=JSON.parse('{"path":"/interview/x-interview4/","title":"为什么定义了索引，但是最终数据库却没有用上？","lang":"zh-CN","frontmatter":{"title":"为什么定义了索引，但是最终数据库却没有用上？","createTime":"2025/02/08 18:32:03","permalink":"/interview/x-interview4/","description":"提示 如果你平时没有想过，那么面试官问出来就很容易卡住。实际上这个问题并不难，但是可能的情况比较多，因此你在回答的时候，不一定能够把面试官想要你回答的所有的点都回答出来。但是并不要紧，你只需要答出三五个点就差不多了，足以证明你对这个问题有比较深刻的理解。 而后在平时注意收集一些索引失效的案例就可以了，尽量在回答的时候用上，就非常完美。 题目分析 数据库...","head":[["meta",{"property":"og:url","content":"https://plume.pengzhanbo.cn/HaiTang-Lab/interview/x-interview4/"}],["meta",{"property":"og:site_name","content":"海棠实验室"}],["meta",{"property":"og:title","content":"为什么定义了索引，但是最终数据库却没有用上？"}],["meta",{"property":"og:description","content":"提示 如果你平时没有想过，那么面试官问出来就很容易卡住。实际上这个问题并不难，但是可能的情况比较多，因此你在回答的时候，不一定能够把面试官想要你回答的所有的点都回答出来。但是并不要紧，你只需要答出三五个点就差不多了，足以证明你对这个问题有比较深刻的理解。 而后在平时注意收集一些索引失效的案例就可以了，尽量在回答的时候用上，就非常完美。 题目分析 数据库..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-08T14:44:19.000Z"}],["meta",{"property":"article:modified_time","content":"2025-02-08T14:44:19.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"为什么定义了索引，但是最终数据库却没有用上？\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-02-08T14:44:19.000Z\\",\\"author\\":[]}"]]},"headers":[],"readingTime":{"minutes":10.2,"words":3060},"git":{"updatedTime":1739025859000,"contributors":[{"name":"hhhbx","username":"hhhbx","email":"972916730@qq.com","commits":2,"avatar":"https://avatars.githubusercontent.com/hhhbx?v=4","url":"https://github.com/hhhbx"}],"changelog":[{"hash":"7040e1c594825ee2813849f6368aa089cb246655","date":1739025859000,"email":"972916730@qq.com","author":"hhhbx","message":"feat(docs): 更新面试题","commitUrl":"https://github.com/pengzhanbo/vuepress-theme-plume/commit/7040e1c594825ee2813849f6368aa089cb246655"},{"hash":"72a9b1b34230dc88b6452a20283e54fe824cc69b","date":1739024507000,"email":"972916730@qq.com","author":"hhhbx","message":"feat(docs): 更新面试题","commitUrl":"https://github.com/pengzhanbo/vuepress-theme-plume/commit/72a9b1b34230dc88b6452a20283e54fe824cc69b"}]},"autoDesc":true,"filePathRelative":"notes/theme/interview/x-interview4.md","bulletin":false}');export{d as comp,k as data};
